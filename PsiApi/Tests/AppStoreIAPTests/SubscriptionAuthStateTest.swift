/*
 * Copyright (c) 2020, Psiphon Inc.
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import XCTest
import ReactiveSwift
import SwiftCheck
import Testing
@testable import PsiApi
@testable import AppStoreIAP
@testable import PsiApiTestingCommon

final class SubscriptionAuthStateTest : XCTestCase {

    /// Test which checks that recursively running the resulting actions of a single action
    /// through the reducer will eventually terminate. This is not done direcly, but the test
    /// will run forever and eventually be killed if this occurs.
    /// Additionally expected state changes are checked.
    func testExternalActions() {

        // These parameters provide better coverage and this test
        // is not focused on generating large random values.
        let checkerArgs = CheckerArguments(replay: nil,
                                           maxAllowableSuccessfulTests: 1000,
                                           maxAllowableDiscardedTests: 5000,
                                           maxTestCaseSize: 10)

        property("Subscription auth state reducer", arguments: checkerArgs) <- forAll {
            (action: SubscriptionAuthStateAction,
            state: SubscriptionReducerState,
            env: SubscriptionAuthStateReducerEnvironment) in

            var actions = [action]
            var inputState = state
            
            while let action = actions.popLast() {

                // Note: a low, but non-zero, timeout is set because some effects
                // returned by the reducer are never completed. A zero timeout
                // causes the timer to expire before the completing effects complete.
                let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                  state: inputState,
                                                                  action: action,
                                                                  env: env)

                // Collect new actions generated by reducer effects
                let newActions =
                    output.actions.compactMap { (x: [Signal<SubscriptionAuthStateAction, SignalProducer<SubscriptionAuthStateAction, Never>.SignalError>.Event]) -> [SubscriptionAuthStateAction] in

                        return x.compactMap { (y: Signal<SubscriptionAuthStateAction, SignalProducer<SubscriptionAuthStateAction, Never>.SignalError>.Event) -> SubscriptionAuthStateAction? in
                            
                            switch y {
                            case .value(let action):
                                return .some(action)
                            default:
                                return .none
                            }
                        }
                    }.flatMap{$0}

                // Add new actions so the last element is the next action.
                actions.append(contentsOf: newActions.reversed())

                switch action {
                case .localDataUpdate(type: _):

                    if output.state != inputState {
                        return (output.state ==== inputState)
                    }

                case .didLoadStoredPurchaseAuthState(loadResult: let loadResult,
                                                     replayDataUpdate: _):
                    switch loadResult {
                    case .success(let loadedValue):
                        var stateCopy = inputState
                        stateCopy.subscription.purchasesAuthState = loadedValue

                        if output.state != stateCopy {
                            return (output.state ==== stateCopy) <?> ".didLoadStoredPurchaseAuthState.sucess"
                        }

                    case .failure(_):
                        var stateCopy = inputState
                        stateCopy.subscription.purchasesAuthState = [:]

                        if output.state != stateCopy {
                            return (output.state ==== stateCopy) <?> ".didLoadStoredPurchaseAuthState.failure"
                        }
                    }

                case ._localDataUpdateResult(_):
                    // Purchases auth state may have changed by:
                    // - being marked as rejected by Psiphon
                    // - being changed from marked as rejected with 400 to not requested
                    var stateCopy = inputState
                    stateCopy.subscription.purchasesAuthState =
                        output.state.subscription.purchasesAuthState
                    break

                case .requestAuthorizationForPurchases:
                    // Txns pending auth request may have changed

                    if (output.state.subscription.transactionsPendingAuthRequest !=
                        inputState.subscription.transactionsPendingAuthRequest) {

                        // Check that max one txn was inserted as pending auth request

                        let diff = output.state.subscription.transactionsPendingAuthRequest.subtracting(inputState.subscription.transactionsPendingAuthRequest)

                        if diff.count > 1 {
                            // Ensure diff is logged
                            return (
                                output.state.subscription.transactionsPendingAuthRequest ====
                                inputState.subscription.transactionsPendingAuthRequest
                                ) <?> ".requestAuthorizationForPurchases.maxOneTxnInserted"
                        }
                    }

                    // Check ignoring txns pending auth request

                    var stateCopy = inputState
                    stateCopy.subscription.transactionsPendingAuthRequest =
                        output.state.subscription.transactionsPendingAuthRequest

                    if output.state != stateCopy {
                        return (output.state ==== stateCopy) <?> ".requestAuthorizationForPurchases.stateEqual"
                    }

                case ._authorizationRequestResult(_, _):

                    if (output.state.subscription.transactionsPendingAuthRequest !=
                        inputState.subscription.transactionsPendingAuthRequest) {

                        // Check that max one txn was removed

                        let diff = inputState.subscription.transactionsPendingAuthRequest.subtracting(output.state.subscription.transactionsPendingAuthRequest)

                        if diff.count > 1 {
                            // Ensure diff is logged
                            return (
                                output.state.subscription.transactionsPendingAuthRequest ====
                                inputState.subscription.transactionsPendingAuthRequest
                                ) <?> "_authorizationRequestResult.maxOneTxnRemoved"
                        }
                    }

                    break
                }

                // Update current state
                inputState = output.state
            }

            return true
        }
    }

    // MARK: _authorizationRequestResult tests

    /// Test which covers when requesting an authorization for a purchase is successful.
    func testAuthorizationRequestCompletedWithSuccess () {
        property("Authorization request succeeded") <- forAll {
            (response: SubscriptionValidationResponse.SuccessResult,
             purchase: SubscriptionIAPPurchase,
             env: SubscriptionAuthStateReducerEnvironment) in

            let updatedPurchase = SubscriptionIAPPurchase(productID: purchase.productID,
                                                         transactionID: purchase.transactionID,
                                                         originalTransactionID: response.originalTransactionID,
                                                         purchaseDate: purchase.purchaseDate,
                                                         expires: purchase.expires,
                                                         isInIntroOfferPeriod: purchase.isInIntroOfferPeriod,
                                                         hasBeenInIntroOfferPeriod: purchase.hasBeenInIntroOfferPeriod)

            var authState = SubscriptionAuthState()
            authState.purchasesAuthState = .some([
                response.originalTransactionID:
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .notRequested)
            ])
            authState.transactionsPendingAuthRequest = [response.originalTransactionID]


            let state = SubscriptionReducerState(subscription: authState,
                                                 receiptData: nil)

            let action: SubscriptionAuthStateAction =
                ._authorizationRequestResult(result: .completed(.success(response)),
                                             forPurchase: updatedPurchase)

            let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                              state: state,
                                                              action: action,
                                                              env: env)

            var expectedNewState = state
            expectedNewState.subscription.transactionsPendingAuthRequest.remove(updatedPurchase.originalTransactionID)

            switch response.errorStatus {
            case .noError:

                if purchase.originalTransactionID != response.originalTransactionID {

                    // Response txn ID does not match that in the request.
                    // Expect that auth state has been updated to `.requestError`.

                    let log: LogMessage = "expected 'signed_authorization' in response '\(response)'"
                    let err = ErrorEvent(ErrorRepr(repr:String(describing:log)),
                                         date: response.requestDate)
                    expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                                           SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                                         signedAuthorization: .requestError(err))
                }

                if let signedAuth = response.signedAuthorization {
                    expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                        SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                        signedAuthorization: .authorization(signedAuth))
                }

            case .transactionExpired:
                expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .requestRejected(.transactionExpired))

            case .transactionCancelled:
                expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .requestRejected(.transactionCancelled))
            }

            return (output.state ==== expectedNewState) <?> String(describing: response.errorStatus)
        }
    }

    /// Test which covers when requesting an authorization for a purchase fails.
    func testAuthorizationRequestCompletedWithFailure () {
        property("Authorization request failed") <- forAll {
            (response: SubscriptionValidationResponse.ResponseError,
             purchase: SubscriptionIAPPurchase,
             env: SubscriptionAuthStateReducerEnvironment) in



            var authState = SubscriptionAuthState()
            authState.purchasesAuthState = .some([
                purchase.originalTransactionID:
                    SubscriptionPurchaseAuthState(purchase: purchase,
                                                  signedAuthorization: .notRequested)
            ])
            authState.transactionsPendingAuthRequest = [purchase.originalTransactionID] // otherwise fatal error


            let state = SubscriptionReducerState(subscription: authState,
                                                 receiptData: nil)

            // if we emit .failure then expect to see txn marked with bad req (non-200 response)
            let action: SubscriptionAuthStateAction =
                ._authorizationRequestResult(result: .completed(.failure(.init(response))),
                                             forPurchase: purchase)

            let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                              state: state,
                                                              action: action,
                                                              env: env)

            var expectedNewState = state
            expectedNewState.subscription.transactionsPendingAuthRequest.remove(purchase.originalTransactionID)

            if SubscriptionValidationResponse.ResponseError.badRequest == response {
                expectedNewState.subscription.purchasesAuthState?[purchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: purchase,
                                                  signedAuthorization: .requestRejected(.badRequestError))
            }

            return output.state ==== expectedNewState
        }
    }

    func testLocalDataUpdateWhenExtensionRejectedAuthorizations () {

        struct IAPPurchaseWithSignedData: Hashable, Arbitrary {
            static var arbitrary: Gen<IAPPurchaseWithSignedData> {
                Gen.compose { c in
                    IAPPurchaseWithSignedData(purchase: c.generate(),
                                              signedData: c.generate())
                }
            }
            let purchase: SubscriptionIAPPurchase
            let signedData: SignedData<SignedAuthorization>
        }

        property("Local data update where the extension has rejected authorizations") <- forAll {
            (updateType: SubscriptionAuthStateAction.StoredDataUpdateType,
            purchasesWithAuth: Set<IAPPurchaseWithSignedData>,
            env: SubscriptionAuthStateReducerEnvironment) in

            // Setup reducer state.

            var inputAuthState = SubscriptionAuthState()
            inputAuthState.purchasesAuthState = .some([:])
            for purchaseWithAuth in purchasesWithAuth {
                inputAuthState.purchasesAuthState?[purchaseWithAuth.purchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: purchaseWithAuth.purchase,
                                                  signedAuthorization: .authorization(purchaseWithAuth.signedData))
            }

            let receiptData = ReceiptData(subscriptionInAppPurchases: Set(purchasesWithAuth.map(\.purchase)),
                                          consumableInAppPurchases: [],
                                          data: Data() /* unused in this test */,
                                          readDate: Date() /* unused in this test */)

            let inputState = SubscriptionReducerState(subscription: inputAuthState,
                                                      receiptData: .some(receiptData))

            // Mark all authorizations as rejected in the shared DB.
            // This will cause the local data update return an action (_localDataUpdateResult)
            // which will mark all the authorizations as rejected.
            (env.sharedDB as! TestSharedDBContainer)
                .state.rejectedSubscriptionAuthorizationIDs =
                purchasesWithAuth.map(\.signedData.decoded.authorization.id)

            // Run local data update action

            let localDataUpdateOutput = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                             state: inputState,
                                                                             action: .localDataUpdate(type: updateType),
                                                                             env: env)

            guard case let ._localDataUpdateResult(transformer) = localDataUpdateOutput.actions.first?.first?.value else {
                return false <?> "Expected ._localDataUpdateResult, but got: \(localDataUpdateOutput)"
            }

            // Run local data update result action

            let localDataUpdateResultOutput = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                                   state: localDataUpdateOutput.state,
                                                                                   action: ._localDataUpdateResult(transformer: transformer),
                                                                                   env: env)

            // Setup the expected final auth state, which is the input state
            // with every authorization marked as `rejectedByPsiphon`.
            var expectedFinalAuthState = SubscriptionAuthState()
            expectedFinalAuthState.purchasesAuthState =
                inputState.subscription.purchasesAuthState?.mapValues {
                    authState -> SubscriptionPurchaseAuthState in

                    switch authState.signedAuthorization {
                    case .authorization(let signedData):
                        var expectedAuth = authState
                        expectedAuth.signedAuthorization = .rejectedByPsiphon(signedData)
                        return expectedAuth
                    default:
                        // Unexpected and test will naturally fail in this scenario.
                        return authState
                    }
            }
            let expectedFinalState = SubscriptionReducerState(subscription: expectedFinalAuthState,
                                                              receiptData: inputState.receiptData)

            return
                // Expect state to be unchanged.
                (inputState ==== localDataUpdateOutput.state) <?> "localDataUpdate action output state check"
                ^&&^
                // Expect authorization state of each purchase to now be `.rejectedByPsiphon`.
                (expectedFinalState ==== localDataUpdateResultOutput.state) <?> "localDataUpdateResult action output state check"
        }
    }

    // MARK: test helpers

    struct ReducerOutputs {
        let state: SubscriptionReducerState
        let actions: [[Signal<SubscriptionAuthStateAction,
                              SignalProducer<SubscriptionAuthStateAction,
                                             Never>.SignalError>
                      .Event]]
    }

    static func runReducer(effectsTimeout: TimeInterval,
                           state: SubscriptionReducerState,
                           action: SubscriptionAuthStateAction,
                           env: SubscriptionAuthStateReducerEnvironment) -> ReducerOutputs {

        let (nextState, effectsResults) =
            testReducer(state, action, env, subscriptionAuthStateReducer, effectsTimeout)

        return ReducerOutputs(state: nextState,
                              actions: effectsResults)
    }
}

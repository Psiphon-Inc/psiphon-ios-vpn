/*
 * Copyright (c) 2020, Psiphon Inc.
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import XCTest
import ReactiveSwift
import SwiftCheck
import Testing
@testable import PsiApi
@testable import AppStoreIAP
@testable import PsiApiTestingCommon

final class SubscriptionAuthStateTest : XCTestCase {

    /// Test which checks that recursively running the resulting actions of a single action
    /// through the reducer will eventually terminate. This is not done direcly, but the test
    /// will run forever and eventually be killed if this occurs.
    /// Additionally expected state changes are checked.
    func testExternalActions() {

        // These parameters provide better coverage and this test
        // is not focused on generating large random values.
        let checkerArgs = CheckerArguments(replay: nil,
                                           maxAllowableSuccessfulTests: 1000,
                                           maxAllowableDiscardedTests: 5000,
                                           maxTestCaseSize: 10)

        property("Subscription auth state reducer", arguments: checkerArgs) <- forAll {
            (action: SubscriptionAuthStateAction,
            state: SubscriptionReducerState,
            env: SubscriptionAuthStateReducerEnvironment) in

            var actions = [action]
            var inputState = state
            
            while let action = actions.popLast() {

                // Note: a low, but non-zero, timeout is set because some effects
                // returned by the reducer are never completed. A zero timeout
                // causes the timer to expire before the completing effects complete.
                let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                  state: inputState,
                                                                  action: action,
                                                                  env: env)

                // Collect new actions generated by reducer effects
                let newActions =
                    output.actions.compactMap { (x: [Signal<SubscriptionAuthStateAction, SignalProducer<SubscriptionAuthStateAction, Never>.SignalError>.Event]) -> [SubscriptionAuthStateAction] in

                        return x.compactMap { (y: Signal<SubscriptionAuthStateAction, SignalProducer<SubscriptionAuthStateAction, Never>.SignalError>.Event) -> SubscriptionAuthStateAction? in
                            
                            switch y {
                            case .value(let action):
                                return .some(action)
                            default:
                                return .none
                            }
                        }
                    }.flatMap{$0}

                // Add new actions so the last element is the next action.
                actions.append(contentsOf: newActions.reversed())

                switch action {
                case .localDataUpdate(type: _):

                    if output.state != inputState {
                        return (output.state ==== inputState)
                    }

                case ._didLoadStoredPurchaseAuthState(loadResult: let loadResult,
                                                     replayDataUpdate: _):
                    switch loadResult {
                    case .success(let loadedValue):
                        var stateCopy = inputState
                        stateCopy.subscription.purchasesAuthState = loadedValue

                        if output.state != stateCopy {
                            return (output.state ==== stateCopy) <?> "._didLoadStoredPurchaseAuthState.sucess"
                        }

                    case .failure(_):
                        var stateCopy = inputState
                        stateCopy.subscription.purchasesAuthState = [:]

                        if output.state != stateCopy {
                            return (output.state ==== stateCopy) <?> "._didLoadStoredPurchaseAuthState.failure"
                        }
                    }

                case ._localDataUpdateResult(_):
                    // Purchases auth state may have changed by:
                    // - being marked as rejected by Psiphon
                    // - being changed from marked as rejected with 400 to not requested
                    var stateCopy = inputState
                    stateCopy.subscription.purchasesAuthState =
                        output.state.subscription.purchasesAuthState
                    break

                case ._requestAuthorizationForPurchases:
                    // Txns pending auth request may have changed

                    if (output.state.subscription.transactionsPendingAuthRequest !=
                        inputState.subscription.transactionsPendingAuthRequest) {

                        // Check that max one txn was inserted as pending auth request

                        let diff = output.state.subscription.transactionsPendingAuthRequest.subtracting(inputState.subscription.transactionsPendingAuthRequest)

                        if diff.count > 1 {
                            // Ensure diff is logged
                            return (
                                output.state.subscription.transactionsPendingAuthRequest ====
                                inputState.subscription.transactionsPendingAuthRequest
                                ) <?> "._requestAuthorizationForPurchases.maxOneTxnInserted"
                        }
                    }

                    // Check ignoring txns pending auth request

                    var stateCopy = inputState
                    stateCopy.subscription.transactionsPendingAuthRequest =
                        output.state.subscription.transactionsPendingAuthRequest

                    if output.state != stateCopy {
                        return (output.state ==== stateCopy) <?> "._requestAuthorizationForPurchases.stateEqual"
                    }

                case ._authorizationRequestResult(_, _):

                    if (output.state.subscription.transactionsPendingAuthRequest !=
                        inputState.subscription.transactionsPendingAuthRequest) {

                        // Check that max one txn was removed

                        let diff = inputState.subscription.transactionsPendingAuthRequest.subtracting(output.state.subscription.transactionsPendingAuthRequest)

                        if diff.count > 1 {
                            // Ensure diff is logged
                            return (
                                output.state.subscription.transactionsPendingAuthRequest ====
                                inputState.subscription.transactionsPendingAuthRequest
                                ) <?> "_authorizationRequestResult.maxOneTxnRemoved"
                        }
                    }

                    break
                }

                // Update current state
                inputState = output.state
            }

            return true
        }
    }

    // MARK: _authorizationRequestResult tests

    /// Test which covers when requesting an authorization for a purchase is successful.
    func testAuthorizationRequestCompletedWithSuccess () {
        property("Authorization request succeeded") <- forAll {
            (response: SubscriptionValidationResponse.SuccessResult,
             purchase: SubscriptionIAPPurchase,
             env: SubscriptionAuthStateReducerEnvironment) in

            let updatedPurchase = SubscriptionIAPPurchase(productID: purchase.productID,
                                                         transactionID: purchase.transactionID,
                                                         originalTransactionID: response.originalTransactionID,
                                                         purchaseDate: purchase.purchaseDate,
                                                         expires: purchase.expires,
                                                         isInIntroOfferPeriod: purchase.isInIntroOfferPeriod,
                                                         hasBeenInIntroOfferPeriod: purchase.hasBeenInIntroOfferPeriod)

            var authState = SubscriptionAuthState()
            authState.purchasesAuthState = .some([
                response.originalTransactionID:
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .notRequested)
            ])
            authState.transactionsPendingAuthRequest = [response.originalTransactionID]


            let state = SubscriptionReducerState(subscription: authState,
                                                 receiptData: nil)

            let action: SubscriptionAuthStateAction =
                ._authorizationRequestResult(result: .completed(.success(response)),
                                             forPurchase: updatedPurchase)

            let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                              state: state,
                                                              action: action,
                                                              env: env)

            var expectedNewState = state
            expectedNewState.subscription.transactionsPendingAuthRequest.remove(updatedPurchase.originalTransactionID)

            switch response.errorStatus {
            case .noError:

                if purchase.originalTransactionID != response.originalTransactionID {

                    // Response txn ID does not match that in the request.
                    // Expect that auth state has been updated to `.requestError`.

                    let log: LogMessage = "expected 'signed_authorization' in response '\(response)'"
                    let err = ErrorEvent(ErrorRepr(repr:String(describing:log)),
                                         date: response.requestDate)
                    expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                                           SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                                         signedAuthorization: .requestError(err))
                }

                if let signedAuth = response.signedAuthorization {
                    expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                        SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                        signedAuthorization: .authorization(signedAuth))
                }

            case .transactionExpired:
                expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .requestRejected(.transactionExpired))

            case .transactionCancelled:
                expectedNewState.subscription.purchasesAuthState?[updatedPurchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: updatedPurchase,
                                                  signedAuthorization: .requestRejected(.transactionCancelled))
            }

            return (output.state ==== expectedNewState) <?> String(describing: response.errorStatus)
        }
    }

    /// Test which covers when requesting an authorization for a purchase fails.
    func testAuthorizationRequestCompletedWithFailure () {
        property("Authorization request failed") <- forAll {
            (responseError: SubscriptionValidationResponse.ResponseError,
             purchase: SubscriptionIAPPurchase,
             env: SubscriptionAuthStateReducerEnvironment) in

            // Arrange
            let fixedDate = Date()
            
            var authState = SubscriptionAuthState()
            authState.purchasesAuthState = .some([
                purchase.originalTransactionID:
                    SubscriptionPurchaseAuthState(purchase: purchase,
                                                  signedAuthorization: .notRequested)
            ])
            authState.transactionsPendingAuthRequest = [purchase.originalTransactionID] // otherwise fatal error


            let state = SubscriptionReducerState(subscription: authState,
                                                 receiptData: nil)
            
            var expectedNewState = state
            expectedNewState.subscription.transactionsPendingAuthRequest
                .remove(purchase.originalTransactionID)

            if SubscriptionValidationResponse.ResponseError.badRequest == responseError {
                expectedNewState.subscription.purchasesAuthState?[purchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: purchase,
                                                  signedAuthorization: .requestRejected(.badRequestError))
            } else {
                expectedNewState.subscription.purchasesAuthState?[purchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: purchase,
                                                  signedAuthorization: .requestError(ErrorEvent(responseError, date: fixedDate
                                                  ).eraseToRepr()))
            }

            // if we emit .failure then expect to see txn marked with bad req (non-200 response)
            let action: SubscriptionAuthStateAction =
                ._authorizationRequestResult(result: .completed(.failure(ErrorEvent(responseError, date: fixedDate))),
                                             forPurchase: purchase)
            
            // Act
            let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                              state: state,
                                                              action: action,
                                                              env: env)

            // Assert
            return output.state ==== expectedNewState
        }
    }

    // MARK: .localDataUpdate tests.

    func testLocalDataUpdateWhenExtensionRejectedAuthorizations () {

        struct IAPPurchaseWithSignedData: Hashable, Arbitrary {
            static var arbitrary: Gen<IAPPurchaseWithSignedData> {
                Gen.compose { c in
                    IAPPurchaseWithSignedData(purchase: c.generate(),
                                              signedData: c.generate())
                }
            }
            let purchase: SubscriptionIAPPurchase
            let signedData: SignedData<SignedAuthorization>
        }

        property("Local data update where the extension has rejected authorizations") <- forAll {
            (updateType: SubscriptionAuthStateAction.StoredDataUpdateType,
            purchasesWithAuth: Set<IAPPurchaseWithSignedData>,
            env: SubscriptionAuthStateReducerEnvironment) in

            // Setup reducer state.

            var inputAuthState = SubscriptionAuthState()
            inputAuthState.purchasesAuthState = .some([:])
            for purchaseWithAuth in purchasesWithAuth {
                inputAuthState.purchasesAuthState?[purchaseWithAuth.purchase.originalTransactionID] =
                    SubscriptionPurchaseAuthState(purchase: purchaseWithAuth.purchase,
                                                  signedAuthorization: .authorization(purchaseWithAuth.signedData))
            }

            let receiptData = ReceiptData(subscriptionInAppPurchases: Set(purchasesWithAuth.map(\.purchase)),
                                          consumableInAppPurchases: [],
                                          data: Data() /* unused in this test */,
                                          readDate: Date() /* unused in this test */)

            let inputState = SubscriptionReducerState(subscription: inputAuthState,
                                                      receiptData: .some(receiptData))

            // Mark all authorizations as rejected in the shared DB.
            // This will cause the local data update return an action (_localDataUpdateResult)
            // which will mark all the authorizations as rejected.
            (env.sharedDB as! TestSharedDBContainer)
                .state.rejectedSubscriptionAuthorizationIDs =
                purchasesWithAuth.map(\.signedData.decoded.authorization.id)

            // Run local data update action

            let localDataUpdateOutput = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                             state: inputState,
                                                                             action: .localDataUpdate(type: updateType),
                                                                             env: env)

            guard case let ._localDataUpdateResult(transformer) = localDataUpdateOutput.actions.first?.first?.value else {
                return false <?> "Expected ._localDataUpdateResult"
            }

            // Run local data update result action

            let localDataUpdateResultOutput = SubscriptionAuthStateTest.runReducer(effectsTimeout: 0.1,
                                                                                   state: localDataUpdateOutput.state,
                                                                                   action: ._localDataUpdateResult(transformer: transformer),
                                                                                   env: env)

            // Setup the expected final auth state, which is the input state
            // with every authorization marked as `rejectedByPsiphon`.
            var expectedFinalAuthState = SubscriptionAuthState()
            expectedFinalAuthState.purchasesAuthState =
                inputState.subscription.purchasesAuthState?.mapValues {
                    authState -> SubscriptionPurchaseAuthState in

                    switch authState.signedAuthorization {
                    case .authorization(let signedData):
                        var expectedAuth = authState
                        expectedAuth.signedAuthorization = .rejectedByPsiphon(signedData)
                        return expectedAuth
                    default:
                        // Unexpected and test will naturally fail in this scenario.
                        return authState
                    }
            }
            let expectedFinalState = SubscriptionReducerState(subscription: expectedFinalAuthState,
                                                              receiptData: inputState.receiptData)

            return
                // Expect state to be unchanged.
                (inputState ==== localDataUpdateOutput.state) <?> "localDataUpdate action output state check"
                ^&&^
                // Expect authorization state of each purchase to now be `.rejectedByPsiphon`.
                (expectedFinalState ==== localDataUpdateResultOutput.state) <?> "localDataUpdateResult action output state check"
        }
    }

    // MARK: ._requestAuthorizationForPurchases tests

    /// Test requesting an authorization for a non-expired purchase.
    /// The tunnel connection and vpn status values are randomized, but end on a combination which will allow the authorization
    /// request to be made (VPN and tunnel are connected).
    func testRequestAuthorizationForPurchases() {

        let tunnelConnectionGen = [TunnelConnection?].arbitrary.resize(100)
        let tunnelProviderVPNStatusGen = [TunnelProviderVPNStatus].arbitrary.resize(100)

        property("Authorization request will eventually succeed") <- forAll(tunnelConnectionGen, tunnelProviderVPNStatusGen) {

            tunnelConnections, vpnStatuses in

            // Only generate non-expired purchases
            let iapPurchaseGen = SubscriptionIAPPurchase.arbitrary.suchThat{$0.expires.timeIntervalSinceNow > 0}

            let tunnelStatusSignal =
                SignalProducer<TunnelProviderVPNStatus, Never>.init(vpnStatuses).concat(value: .connected)


            let finalTunnelConnection: TunnelConnection? = .some(TunnelConnection{.connection(.connected)})
            let tunnelConnectionRefSignal =
                SignalProducer<TunnelConnection?, Never>.init(tunnelConnections).concat(value: finalTunnelConnection)

            let envGen =
                SubscriptionAuthStateReducerEnvironment
                    .arbitraryWithTunnelSignals(
                        tunnelStatusSignal: tunnelStatusSignal,
                        tunnelConnectionRefSignal: tunnelConnectionRefSignal)

            return forAll(iapPurchaseGen, envGen) {
                purchase, env in

                // Mark the purchase as `.notRequested`.
                var authState = SubscriptionAuthState()
                authState.purchasesAuthState = .some([
                    purchase.originalTransactionID:
                        SubscriptionPurchaseAuthState(purchase: purchase,
                                                      signedAuthorization: .notRequested)
                ])

                let receiptData = ReceiptData(subscriptionInAppPurchases: Set(arrayLiteral:purchase),
                                              consumableInAppPurchases: [],
                                              data: Data() /* unused in this test */,
                                              readDate: Date() /* unused in this test */)

                let state = SubscriptionReducerState(subscription: authState,
                                                     receiptData: receiptData)

                let output = SubscriptionAuthStateTest.runReducer(effectsTimeout: 10,
                                                                  state: state,
                                                                  action: ._requestAuthorizationForPurchases,
                                                                  env: env)

                guard let actions = output.actions.first else {
                        return false <?> "Expected actions from reducer"
                }

                guard actions.count >= 2 else {
                    return false <?> "Expected 2 or more actions from reducer"
                }

                // Take the second last action since the last one will be the
                // materialized completed.
                let finalAction = actions[actions.count-2]

                switch finalAction {
                case .value(._authorizationRequestResult(result: let result, forPurchase: purchase)):
                    switch result {
                    case .willRetry(_):
                        return false <?> "Expected that the request was attempted"
                    default:
                        break
                    }
                default:
                    return false <?> "Expected second last action to be completed"
                }

                // Expect the state to have the given purchase as pending auth request.
                var expectedNewState = state
                expectedNewState.subscription.transactionsPendingAuthRequest.insert(purchase.originalTransactionID)

                return output.state ==== expectedNewState
            }
        }
    }

    // MARK: test helpers

    struct ReducerOutputs {
        let state: SubscriptionReducerState
        let actions: [[Signal<SubscriptionAuthStateAction,
                              SignalProducer<SubscriptionAuthStateAction,
                                             Never>.SignalError>
                      .Event]]
    }

    static func runReducer(effectsTimeout: TimeInterval,
                           state: SubscriptionReducerState,
                           action: SubscriptionAuthStateAction,
                           env: SubscriptionAuthStateReducerEnvironment) -> ReducerOutputs {

        let (nextState, effectsResults) =
            testReducer(state, action, env, subscriptionAuthStateReducer, effectsTimeout)

        return ReducerOutputs(state: nextState,
                              actions: effectsResults)
    }
}
